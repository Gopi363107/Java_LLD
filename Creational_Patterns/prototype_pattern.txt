âœ… 2ï¸âƒ£ COMPARISON (Now clearly shown)
ğŸ”¹ Shallow Copy vs Deep Copy vs Cloneable

Feature	        Shallow Copy	    Deep Copy	    Java Cloneable

Object created	    Yes	                Yes	            Yes
Nested objects	  Shared	        New copies	    Shared by default
Safe	        âŒ Risky	            âœ… Safe	        âŒ Risky
Control over copy	Medium	            Full	        Very low
Checked exception	âŒ No	        âŒ No	        âœ… Yes
Industry usage	   Limited	        Preferred	        âŒ Avoided
Interview value	   â­â­â­	       â­â­â­â­â­	    â­â­


1ï¸âƒ£ What is Prototype Pattern? (Basic)
ğŸ”¹ Definition

Prototype Pattern is a creational design pattern that creates new objects by cloning an existing object, instead of creating them from scratch.

ğŸ“Œ Key idea:

Copy an existing object to create a new one.

2ï¸âƒ£ Why Prototype Pattern? (Problem Statement)
Problem with new keyword
GameCharacter character = new GameCharacter();


âŒ Problems:

Object creation is expensive

Complex setup (DB calls, network calls, heavy configs)

Repeating same initialization logic

Solution

Create one object, then clone it multiple times.

âœ” Faster
âœ” Efficient
âœ” Cleaner

3ï¸âƒ£ Real-Life Analogy ğŸŒ

Photocopy machine

Original document = Prototype

Copies = Cloned objects

Game characters

Base character â†’ clone â†’ customize

4ï¸âƒ£ When to Use Prototype Pattern?

Use Prototype when:

Object creation is costly

You need many similar objects

Objects are created at runtime

You want to avoid complex constructors

5ï¸âƒ£ Core Structure (Components)

Prototype (Interface / Abstract Class)

Concrete Prototype

Client

(Optional) Prototype Registry

6ï¸âƒ£ Simple Java Example (Basic)
Step 1: Prototype Interface
interface Prototype {
    Prototype clone();
}

Step 2: Concrete Prototype
class Student implements Prototype {
    String name;
    int age;

    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Prototype clone() {
        return new Student(this.name, this.age);
    }
}

Step 3: Client Code
public class Main {
    public static void main(String[] args) {
        Student s1 = new Student("Gopi", 20);
        Student s2 = (Student) s1.clone();

        System.out.println(s1.name);
        System.out.println(s2.name);
    }
}


âœ” s2 is a new object
âœ” Data copied from s1

7ï¸âƒ£ Shallow Copy vs Deep Copy (VERY IMPORTANT)
ğŸ”¹ Shallow Copy

Copies references

Both objects share same internal objects

class Address {
    String city;
}


âŒ Risky if object is mutable

ğŸ”¹ Deep Copy

Copies actual objects

Completely independent

âœ” Safe
âœ” Preferred

Example
class Student implements Prototype {
    String name;
    Address address;

    public Prototype clone() {
        return new Student(name, new Address(address.city));
    }
}

8ï¸âƒ£ Java Cloneable Interface (Intermediate)

Java provides built-in cloning.

class Student implements Cloneable {
    String name;

    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}


âŒ Problems with Cloneable

Shallow copy by default

No clone() in interface

Confusing API

ğŸ‘‰ In LLD, avoid Cloneable
ğŸ‘‰ Use custom clone method

9ï¸âƒ£ Prototype Registry (Advanced Concept) ğŸ§ 

Instead of cloning directly, store prototypes in a registry.

Example
class PrototypeRegistry {
    private static Map<String, Prototype> registry = new HashMap<>();

    static {
        registry.put("student", new Student("Default", 18));
    }

    public static Prototype getPrototype(String key) {
        return registry.get(key).clone();
    }
}

Client
Student s1 = (Student) PrototypeRegistry.getPrototype("student");


âœ” Centralized
âœ” Easy extension

ğŸ”Ÿ Advanced Use Case â€“ Game Character System ğŸ®
abstract class GameCharacter {
    int health;
    int attack;

    abstract GameCharacter clone();
}

class Warrior extends GameCharacter {
    public GameCharacter clone() {
        Warrior w = new Warrior();
        w.health = this.health;
        w.attack = this.attack;
        return w;
    }
}

1ï¸âƒ£1ï¸âƒ£ Prototype vs Builder vs Factory
Pattern	Purpose
Factory	Creates objects
Builder	Step-by-step creation
Prototype	Copy existing object

ğŸ‘‰ Prototype is best when objects already exist

1ï¸âƒ£2ï¸âƒ£ Advantages âœ…

âœ” Faster object creation
âœ” Avoids complex constructors
âœ” Runtime flexibility
âœ” Reduces subclassing

1ï¸âƒ£3ï¸âƒ£ Disadvantages âŒ

âœ– Complex deep cloning
âœ– Hard with circular references
âœ– Debugging is tricky

1ï¸âƒ£4ï¸âƒ£ Interview Questions (Important)
Q: When will you choose Prototype?

âœ” When object creation is expensive
âœ” When many similar objects are needed

Q: Shallow vs Deep?

âœ” Always explain with example

Q: Is Prototype used in real systems?

âœ” Game engines
âœ” Cache systems
âœ” Object pools

ğŸ¯ Interview One-Liner (MEMORIZE)

Prototype Pattern creates new objects by cloning an existing object rather than creating them from scratch.

______________________________________________________________________________________________________________________

1ï¸âƒ£ SHALLOW COPY (Explain separately)
ğŸ“Œ What is Shallow Copy?

A shallow copy creates a new object, but copies references of non-primitive fields instead of creating new objects for them.

ğŸ‘‰ Primitive values are copied
ğŸ‘‰ Reference objects are shared

ğŸ” Example (Shallow Copy)
class Address {
    String city;

    Address(String city) {
        this.city = city;
    }
}

class Student {
    String name;
    Address address;

    Student(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    Student clone() {
        return new Student(this.name, this.address); // shallow copy
    }
}

What happens?

name â†’ copied

address â†’ same object shared

If you change:

s2.address.city = "Chennai";


ğŸ‘‰ s1.address.city also becomes "Chennai"

âš ï¸ This is the problem with shallow copy

ğŸ§  Key Point

Shallow copy is fast, but unsafe when mutable objects exist.

2ï¸âƒ£ DEEP COPY (Explain separately)
ğŸ“Œ What is Deep Copy?

A deep copy creates:

A new object

AND new copies of all nested objects

ğŸ‘‰ No shared references
ğŸ‘‰ Completely independent objects

ğŸ” Example (Deep Copy)
class Student {
    String name;
    Address address;

    Student(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    Student clone() {
        return new Student(
            this.name,
            new Address(this.address.city) // deep copy
        );
    }
}

What happens?

name â†’ copied

address â†’ new Address object created

If you change:

s2.address.city = "Chennai";


ğŸ‘‰ s1.address.city remains unchanged âœ…

ğŸ§  Key Point

Deep copy is safe, but slightly slower.

3ï¸âƒ£ COMPARISON (After explaining both)
Feature	Shallow Copy	Deep Copy
Object created	Yes	Yes
Primitive fields	Copied	Copied
Reference fields	Shared	New objects
Safe for mutable objects	âŒ No	âœ… Yes
Performance	Faster	Slightly slower
Used when	Simple objects	Complex objects
4ï¸âƒ£ Where your UPSC Examiner code fits

Your code:

public UPSC clone(){
    return new Examiner(this.name , this.age , this.id , this.year);
}

Why this is Shallow Copy?

int â†’ primitive

String â†’ immutable

No nested mutable objects

âœ… Safe shallow copy
âœ… Industry-recommended approach
âœ… Better than Cloneable

5ï¸âƒ£ Interview One-Liner (Very important â­)

Shallow copy copies object references, while deep copy creates independent copies of all nested objects.

âœ… We have COMPLETED:

âœ” Shallow Copy
âœ” Deep Copy
âœ” Comparison
âœ” Prototype Pattern relation