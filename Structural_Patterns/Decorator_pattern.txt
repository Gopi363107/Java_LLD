1ï¸âƒ£ What is Decorator Pattern? (Basic)
ğŸ”¹ Definition

Decorator Pattern allows you to add new behavior to an object dynamically without modifying its class.

ğŸ‘‰ Add features at runtime instead of creating subclasses.

2ï¸âƒ£ Why Decorator Pattern? (Problem)
Without Decorator

You create subclasses for every feature combination.

âŒ Class explosion problem
âŒ Hard to maintain
âŒ Violates Openâ€“Closed Principle

Example without Decorator
Coffee
 â”œâ”€â”€ CoffeeWithMilk
 â”œâ”€â”€ CoffeeWithSugar
 â”œâ”€â”€ CoffeeWithMilkAndSugar
 â”œâ”€â”€ CoffeeWithCreamAndSugar


ğŸš¨ Too many classes!

3ï¸âƒ£ Real-Life Analogy ğŸŒ

â˜• Coffee Shop

Base coffee

Add milk

Add sugar

Add cream

ğŸ‘‰ Features are added dynamically

4ï¸âƒ£ Key Idea of Decorator Pattern

Wrap an object inside another object

Decorator has same interface

Client doesnâ€™t know if object is decorated or not

5ï¸âƒ£ Structure of Decorator Pattern
Participants:

Component â€“ common interface

Concrete Component â€“ base object

Decorator â€“ abstract wrapper

Concrete Decorators â€“ add behavior

6ï¸âƒ£ UML-Level View (Interview)
Client â†’ Component
             â†‘
        Decorator
             â†‘
     ConcreteDecorator

7ï¸âƒ£ Simple Java Example (Basic)
Step 1: Component
interface Coffee {
    int cost();
    String description();
}

Step 2: Concrete Component
class SimpleCoffee implements Coffee {
    public int cost() {
        return 50;
    }

    public String description() {
        return "Simple Coffee";
    }
}

Step 3: Decorator (Abstract)
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;

    CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

Step 4: Concrete Decorators
class MilkDecorator extends CoffeeDecorator {

    MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    public int cost() {
        return coffee.cost() + 20;
    }

    public String description() {
        return coffee.description() + ", Milk";
    }
}

class SugarDecorator extends CoffeeDecorator {

    SugarDecorator(Coffee coffee) {
        super(coffee);
    }

    public int cost() {
        return coffee.cost() + 10;
    }

    public String description() {
        return coffee.description() + ", Sugar";
    }
}

Step 5: Client Code
public class Main {
    public static void main(String[] args) {
        Coffee coffee =
            new MilkDecorator(
                new SugarDecorator(
                    new SimpleCoffee()
                )
            );

        System.out.println(coffee.description());
        System.out.println("Cost: " + coffee.cost());
    }
}


âœ” Output:

Simple Coffee, Sugar, Milk
Cost: 80

8ï¸âƒ£ Decorator vs Inheritance (IMPORTANT)
Inheritance	Decorator
Compile-time	Runtime
Rigid	Flexible
Class explosion	No explosion
9ï¸âƒ£ Real-World Use Case â€“ BookMyShow ğŸŸï¸

Base ticket:

Ticket


Decorators:

FoodCombo

ReclinerSeat

Insurance

ğŸ‘‰ Price calculated dynamically
ğŸ‘‰ No subclass explosion

ğŸ”Ÿ Decorator vs Adapter vs Facade (CONFUSION CLEAR)
Pattern	Purpose
Adapter	Interface conversion
Decorator	Add behavior
Facade	Simplify system
1ï¸âƒ£1ï¸âƒ£ Advantages âœ…

âœ” Openâ€“Closed Principle
âœ” Runtime flexibility
âœ” Avoids subclass explosion
âœ” Clean design

1ï¸âƒ£2ï¸âƒ£ Disadvantages âŒ

âœ– Many small objects
âœ– Harder debugging
âœ– Order of decoration matters

1ï¸âƒ£3ï¸âƒ£ Where Decorator is Used?

âœ” Java I/O (BufferedInputStream)
âœ” UI components
âœ” Pricing systems
âœ” Logging frameworks

1ï¸âƒ£4ï¸âƒ£ Interview One-Liner (MEMORIZE)

Decorator Pattern dynamically adds behavior to an object without modifying its structure.

âœ… Decorator Pattern DONE âœ”