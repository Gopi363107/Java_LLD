ğŸ§± SOLID Principles (LLD Core)

Weâ€™ll cover one principle at a time in this order:

S â€“ Single Responsibility Principle (SRP)
O â€“ Open/Closed Principle (OCP)
L â€“ Liskov Substitution Principle (LSP)
I â€“ Interface Segregation Principle (ISP)
D â€“ Dependency Inversion Principle (DIP)

For each principle, Iâ€™ll explain:

Simple definition (1â€“2 lines)

Bad design âŒ
Improved design âœ…
Real-world analogy
Interview tips
____________________________________________________________________________________________________________________
1ï¸âƒ£ Single Responsibility Principle (SRP)
ğŸ”¹ Definition

A class should have only one reason to change.

ğŸ‘‰ In simple words:
One class = One job

âŒ Bad Design (Violation of SRP)
class Invoice {
    void calculateTotal() {
        // business logic
    }

    void printInvoice() {
        // printing logic
    }

    void saveToDatabase() {
        // DB logic
    }
}

âŒ Problems

Business logic + printing + DB = multiple responsibilities

Any change in printing or DB affects Invoice

Hard to test & maintain

âœ… Good Design (Following SRP)
class Invoice {
    void calculateTotal() {
        // business logic
    }
}

class InvoicePrinter {
    void print(Invoice invoice) {
        // printing logic
    }
}

class InvoiceRepository {
    void save(Invoice invoice) {
        // DB logic
    }
}

âœ… Benefits

Each class has one responsibility

Easy to modify, test, and extend

Cleaner LLD design

ğŸŒ Real-World Analogy

ğŸ‘¨â€ğŸ³ Chef cooks
ğŸ§¾ Accountant handles bills
ğŸ–¨ï¸ Clerk prints receipts

One person â†’ one responsibility

ğŸ¯ Interview One-Liner

â€œSRP states that a class should have only one reason to change, 
meaning it should handle only one responsibility.â€

ğŸ§  Common Interview Trap

â“ Is SRP about one method per class?
âŒ No
âœ… Itâ€™s about one responsibility, not one method

âœ”ï¸ SRP Summary

Improves maintainability

Reduces side effects

Makes LLD clean and extensible
____________________________________________________________________________________________________________________

ğŸ§± Open / Closed Principle (OCP)
ğŸ”¹ Definition

Software entities (classes, modules, functions) should be
OPEN for extension but CLOSED for modification

ğŸ“Œ Meaning in simple words
You should be able to add new behavior without changing existing code.

âŒ OCP Violation (Bad Design)
ğŸ¯ Example: Discount System
class DiscountCalculator {

    double calculateDiscount(String customerType, double amount) {
        if (customerType.equals("STUDENT")) {
            return amount * 0.10;
        } else if (customerType.equals("SENIOR")) {
            return amount * 0.20;
        } else if (customerType.equals("EMPLOYEE")) {
            return amount * 0.30;
        }
        return 0;
    }
}

âŒ Problems

Every new customer type â†’ modify this class

High risk of breaking existing logic

Violates OCP

âœ… OCP Followed (Clean LLD Design)
ğŸ”¹ Step 1: Create an abstraction
interface DiscountStrategy {
    double applyDiscount(double amount);
}

ğŸ”¹ Step 2: Extend behavior using new classes
class StudentDiscount implements DiscountStrategy {
    public double applyDiscount(double amount) {
        return amount * 0.10;
    }
}

class SeniorDiscount implements DiscountStrategy {
    public double applyDiscount(double amount) {
        return amount * 0.20;
    }
}

class EmployeeDiscount implements DiscountStrategy {
    public double applyDiscount(double amount) {
        return amount * 0.30;
    }
}

ğŸ”¹ Step 3: Closed for modification
class DiscountCalculator {
    double calculate(DiscountStrategy strategy, double amount) {
        return strategy.applyDiscount(amount);
    }
}


ğŸ‘‰ Now:

Add NewDiscount â†’ just create a new class

âŒ No modification in DiscountCalculator

ğŸ§  Real-World Analogy

ğŸ”Œ Plug socket
You can plug new devices without changing the socket design.

ğŸ¯ Interview One-Liner

â€œOCP means we should extend system behavior using new classes instead of modifying existing, tested code.â€

âš  Common Interview Trap

â“ Is OCP achieved using inheritance only?
âŒ No
âœ… Interfaces + composition is preferred

ğŸ§© Your Turn (Practice Time)
ğŸŸ¡ Medium-Level OCP Question (DO THIS)

System: Notification System

ğŸ‘‰ Requirements:

Send notification

Types:

Email
SMS
WhatsApp

â“ Task:

First think of OCP violation
Then design system following OCP
Use interface + implementation
Write a Main class

ğŸ’¡ Hint:

Notification â†’ abstraction
Email / SMS / WhatsApp â†’ extension

____________________________________________________________________________________________________________________________

