____________________________________________________________________________________________________________________
use this line to delete all .class file : 

Get-ChildItem -Path 'C:\Users\LENOVO\Desktop\Java_LLD\Practices_LLD' -Filter *.class -Recurse |Remove-Item -Force
____________________________________________________________________________________________________________________
ğŸ§± SOLID Principles (LLD Core)

Weâ€™ll cover one principle at a time in this order:

S â€“ Single Responsibility Principle (SRP)
O â€“ Open/Closed Principle (OCP)
L â€“ Liskov Substitution Principle (LSP)
I â€“ Interface Segregation Principle (ISP)
D â€“ Dependency Inversion Principle (DIP)

For each principle, Iâ€™ll explain:

Simple definition (1â€“2 lines)

Bad design âŒ
Improved design âœ…
Real-world analogy
Interview tips
____________________________________________________________________________________________________________________
1ï¸âƒ£ Single Responsibility Principle (SRP)
ğŸ”¹ Definition

A class should have only one reason to change.

ğŸ‘‰ In simple words:
One class = One job

âŒ Bad Design (Violation of SRP)
class Invoice {
    void calculateTotal() {
        // business logic
    }

    void printInvoice() {
        // printing logic
    }

    void saveToDatabase() {
        // DB logic
    }
}

âŒ Problems

Business logic + printing + DB = multiple responsibilities

Any change in printing or DB affects Invoice

Hard to test & maintain

âœ… Good Design (Following SRP)
class Invoice {
    void calculateTotal() {
        // business logic
    }
}

class InvoicePrinter {
    void print(Invoice invoice) {
        // printing logic
    }
}

class InvoiceRepository {
    void save(Invoice invoice) {
        // DB logic
    }
}

âœ… Benefits

Each class has one responsibility

Easy to modify, test, and extend

Cleaner LLD design

ğŸŒ Real-World Analogy

ğŸ‘¨â€ğŸ³ Chef cooks
ğŸ§¾ Accountant handles bills
ğŸ–¨ï¸ Clerk prints receipts

One person â†’ one responsibility

ğŸ¯ Interview One-Liner

â€œSRP states that a class should have only one reason to change, 
meaning it should handle only one responsibility.â€

ğŸ§  Common Interview Trap

â“ Is SRP about one method per class?
âŒ No
âœ… Itâ€™s about one responsibility, not one method

âœ”ï¸ SRP Summary

Improves maintainability

Reduces side effects

Makes LLD clean and extensible
____________________________________________________________________________________________________________________

ğŸ§± Open / Closed Principle (OCP)
ğŸ”¹ Definition

Software entities (classes, modules, functions) should be
OPEN for extension but CLOSED for modification

ğŸ“Œ Meaning in simple words
You should be able to add new behavior without changing existing code.

âŒ OCP Violation (Bad Design)
ğŸ¯ Example: Discount System
class DiscountCalculator {

    double calculateDiscount(String customerType, double amount) {
        if (customerType.equals("STUDENT")) {
            return amount * 0.10;
        } else if (customerType.equals("SENIOR")) {
            return amount * 0.20;
        } else if (customerType.equals("EMPLOYEE")) {
            return amount * 0.30;
        }
        return 0;
    }
}

âŒ Problems

Every new customer type â†’ modify this class

High risk of breaking existing logic

Violates OCP

âœ… OCP Followed (Clean LLD Design)
ğŸ”¹ Step 1: Create an abstraction
interface DiscountStrategy {
    double applyDiscount(double amount);
}

ğŸ”¹ Step 2: Extend behavior using new classes
class StudentDiscount implements DiscountStrategy {
    public double applyDiscount(double amount) {
        return amount * 0.10;
    }
}

class SeniorDiscount implements DiscountStrategy {
    public double applyDiscount(double amount) {
        return amount * 0.20;
    }
}

class EmployeeDiscount implements DiscountStrategy {
    public double applyDiscount(double amount) {
        return amount * 0.30;
    }
}

ğŸ”¹ Step 3: Closed for modification
class DiscountCalculator {
    double calculate(DiscountStrategy strategy, double amount) {
        return strategy.applyDiscount(amount);
    }
}


ğŸ‘‰ Now:

Add NewDiscount â†’ just create a new class

âŒ No modification in DiscountCalculator

ğŸ§  Real-World Analogy

ğŸ”Œ Plug socket
You can plug new devices without changing the socket design.

ğŸ¯ Interview One-Liner

â€œOCP means we should extend system behavior using new classes instead of modifying existing, tested code.â€

âš  Common Interview Trap

â“ Is OCP achieved using inheritance only?
âŒ No
âœ… Interfaces + composition is preferred

ğŸ§© Your Turn (Practice Time)
ğŸŸ¡ Medium-Level OCP Question (DO THIS)

System: Notification System

ğŸ‘‰ Requirements:

Send notification

Types:

Email
SMS
WhatsApp

â“ Task:

First think of OCP violation
Then design system following OCP
Use interface + implementation
Write a Main class

ğŸ’¡ Hint:

Notification â†’ abstraction
Email / SMS / WhatsApp â†’ extension

____________________________________________________________________________________________________________________________

ğŸ§± Liskov Substitution Principle (LSP)

ğŸ”¹ Official Definition
Objects of a superclass should be replaceable with objects of its subclasses without breaking the program.
ğŸ“Œ Sounds confusing? Letâ€™s simplify ğŸ‘‡

ğŸ§  Simple Meaning (Very Important)

If class B is a child of class A,
then B should behave like A, not surprise the system.
ğŸ‘‰ Anywhere the parent is expected, the child should work correctly.

âŒ Classic Wrong Understanding

LSP is NOT just about:
Inheritance
Method overriding compiling successfully

âŒ Code compiling â‰  LSP followed

ğŸš¨ Most Common LSP Violation (Interview Favorite)
âŒ Bad Design Example: Bird
class Bird {
    void fly() {
        System.out.println("Bird is flying");
    }
}

class Ostrich extends Bird {
    void fly() {
        throw new UnsupportedOperationException("Ostrich can't fly");
    }
}

âŒ Why this violates LSP

Ostrich IS-A Bird (by inheritance)
But it cannot fly
Any code expecting a Bird that flies will break

ğŸ‘‰ Substitution fails

ğŸ§  Key LSP Rule (MEMORIZE)
A subclass should not weaken the behavior promised by the parent class.

âœ… Correct Design (LSP Followed)
âœ” Fix by separating behavior
interface Flyable {
    void fly();
}

class Sparrow implements Flyable {
    public void fly() {
        System.out.println("Sparrow flying");
    }
}

class Ostrich {
    // no fly method
}

ğŸ‘‰ Now:

Only birds that can fly implement Flyable
No broken substitution

ğŸ” LSP IN REAL SYSTEMS (INTERVIEW LEVEL)

Now letâ€™s apply LSP to something close to what you already know.

ğŸ›’ Example: Payment System (LSP)
âŒ LSP Violation
class Payment {
    void pay(double amount) {
        System.out.println("Payment processed: " + amount);
    }
}

class CashPayment extends Payment {
    void pay(double amount) {
        System.out.println("Cash payment done");
    }
}

class CreditCardPayment extends Payment {
    void pay(double amount) {
        if (amount > 50000) {
            throw new RuntimeException("Limit exceeded");
        }
        System.out.println("Card payment done");
    }
}

âŒ Why this violates LSP

Parent Payment promises: â€œI can pay any amountâ€
Child CreditCardPayment adds restriction
Substitution breaks for large amounts

âœ… LSP-CORRECT DESIGN
âœ” Define correct abstraction
interface PaymentMethod {
    void pay(double amount);
}

class CashPayment implements PaymentMethod {
    public void pay(double amount) {
        System.out.println("Cash payment: " + amount);
    }
}

class CreditCardPayment implements PaymentMethod {
    public void pay(double amount) {
        System.out.println("Card payment: " + amount);
    }
}


ğŸ‘‰ Validation rules move outside or into a separate validator.

ğŸ§  LSP GOLDEN RULE (WRITE THIS)

Subclasses must honor the contract of the parent class.
Contract includes:
Expected behavior
Input assumptions
Output guarantees

Exceptions
ğŸ¯ How Interviewers Test LSP

They ask:

â€œIs Square a Rectangle?â€
â€œIs every Bird able to fly?â€
â€œCan child throw new exceptions?â€

Correct mindset:

Inheritance should represent behavioral compatibility, not just code reuse.

ğŸ§© Your Turn (Very Important)
ğŸŸ¡ LSP PRACTICE QUESTION

System: Notification System

ğŸ‘‰ You already built this.

â“ Task:

Create a base Notification abstraction

Create:
EmailNotification
SMSNotification

Ensure:

Any notification can replace another
No subclass breaks expected behavior

ğŸ’¡ Hint:

No method should suddenly:
Throw unsupported exceptions
Ignore required behavior
OR (Alternative if you prefer)

Say:

â€œExplain LSP again using Order Processing Systemâ€
Iâ€™ll re-explain using Order / Payment / Invoice, step-by-step.

____________________________________________________________________________________________________________________

ğŸ”¹ Interface Segregation Principle (ISP)

ğŸ“Œ Definition (Interview-Ready)

No client should be forced to depend on methods it does not use.
ğŸ‘‰ Many small, specific interfaces are better than one large interface.

1ï¸âƒ£ Real-Life Intuition (Simple)

Imagine a remote control:
TV needs: powerOn(), changeChannel()
AC needs: powerOn(), setTemperature()

âŒ Bad: One remote with all buttons for everyone
âœ… Good: Separate remotes for TV and AC

Thatâ€™s ISP.

2ï¸âƒ£ ISP Violation Example âŒ (Very Common in Interviews)
âŒ Fat Interface
interface Worker {
    void work();
    void eat();
}

âŒ Problematic Implementation
class RobotWorker implements Worker {
    public void work() {
        System.out.println("Robot is working");
    }

    public void eat() {
        // âŒ Robot does not eat
    }
}

ğŸš¨ Why ISP is violated?

Robot is forced to implement eat()
Client depends on a method it doesnâ€™t need
Empty / dummy methods = design smell

3ï¸âƒ£ Correct ISP Design âœ…
âœ… Segregated Interfaces
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

âœ… Implement Only What Is Needed
class HumanWorker implements Workable, Eatable {
    public void work() {
        System.out.println("Human is working");
    }

    public void eat() {
        System.out.println("Human is eating");
    }
}

class RobotWorker implements Workable {
    public void work() {
        System.out.println("Robot is working");
    }
}


ğŸ”¥ Clean
ğŸ”¥ Flexible
ğŸ”¥ ISP satisfied

4ï¸âƒ£ Payment System â€“ ISP Version (Connected to Your LSP)

You already thought about this ğŸ‘Œ

âœ… Interfaces
interface Payment {
    void processPayment();
}

interface Refundable {
    void refund();
}

âœ… Implementations
class CreditCardPayment implements Payment, Refundable {
    public void processPayment() {
        System.out.println("Credit card payment processed");
    }

    public void refund() {
        System.out.println("Credit card refund processed");
    }
}

class CashPayment implements Payment {
    public void processPayment() {
        System.out.println("Cash payment processed");
    }
}

ğŸ’¡ Why this is perfect?

Cash is not forced to implement refund
Interfaces are role-based
ISP + LSP both satisfied

5ï¸âƒ£ Interview Pattern Recognition ğŸ§ 

ISP problems usually involve:

Printer / Scanner / Fax
Payment / Refund
User permissions
Workers / Robots
File readers (read / write)
If you see:
Empty methods

throw UnsupportedOperationException
ğŸ‘‰ ISP is violated âŒ

6ï¸âƒ£ One-Line Interview Answer (Must Remember)

â€œISP ensures that a class only implements interfaces relevant to its behavior, 
avoiding fat interfaces and unused methods.â€

7ï¸âƒ£ Your Turn ğŸ¯ (Practice Question)

ğŸŸ¡ Medium-Level ISP Question

System: Printer System

Operations:

print()
scan()
fax()

Devices:

BasicPrinter (only print)
OfficePrinter (print, scan, fax)

ğŸ‘‰ Task:

Identify ISP violation
Design correct interfaces
Write clean Java code

____________________________________________________________________________________________________________________

ğŸ§  Dependency Inversion Principle (DIP)
ğŸ”‘ Definition (Simple)

High-level modules should not depend on low-level modules.
Both should depend on abstractions.

ğŸ” Apply it to your Printer System
âŒ Wrong (Violates DIP)
OfficePrinter printer = new OfficePrinter();
printer.print();


Why wrong?

PrinterSystem is tightly coupled to OfficePrinter
If tomorrow we add SmartPrinter, you must modify code âŒ

âœ… Correct (Follows DIP)
Printable printer = new OfficePrinter();
printer.print();


Why correct?

PrinterSystem depends on abstractions
OfficePrinter, BasicPrinter, SmartPrinter can change freely
System is flexible, extensible, testable

ğŸ”¥ This is true DIP

ğŸ§± Role of Each Layer (Interview Gold)
High-Level Module
PrinterSystem (main logic)

Abstractions
Printable
Scannable
Faxable

Low-Level Modules
BasicPrinter
OfficePrinter


ğŸ‘‰ Both depend on interfaces
ğŸ‘‰ No direct dependency on concrete classes

ğŸ—£ï¸ Interview-Ready Explanation (Say This)

â€œI applied Dependency Inversion Principle by making the system depend on printer capability interfaces like Printable, Scannable, and Faxable instead of concrete printer classes. This decouples high-level logic from low-level implementations.â€

ğŸ’¯ This answer alone can clear an LLD round.

ğŸ SOLID â€” COMPLETED ğŸ‰
Principle	Status
SRP	âœ…
OCP	âœ…
LSP	âœ…
ISP	âœ…
DIP	âœ…

Youâ€™ve officially completed SOLID with real code, not theory.

